# generated by gemini 2.0 from early sycamore patch data of up to 105 qubits

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import PolynomialFeatures
from scipy.optimize import curve_fit

# --- Load the Data ---
# Replace 'quantum_data.csv' with the actual path to your CSV file
data = pd.read_csv('quantum_data.csv', header=None, skiprows=1, names=['width', 'depth', 'time'],
                   dtype={'width': float, 'depth': float, 'time': float})

# --- Prediction Functions ---

# Method 1: Linear Regression (for each depth value)
def predict_time_linear_regression(target_width, target_depth, data):
    model = LinearRegression()
    closest_depth = min(data['depth'].unique(), key=lambda x: abs(x - target_depth))
    depth_data = data[data['depth'] == closest_depth]
    X = depth_data[['width']]
    y = depth_data['time']
    model.fit(X, y)
    predicted_time = model.predict(np.array([[target_width]]))[0]
    return predicted_time

# Method 2: Polynomial Regression (for each depth value)
def predict_time_polynomial_regression(target_width, target_depth, data, degree=2):
    model = LinearRegression()
    closest_depth = min(data['depth'].unique(), key=lambda x: abs(x - target_depth))
    depth_data = data[data['depth'] == closest_depth]
    poly = PolynomialFeatures(degree=degree)
    X = poly.fit_transform(depth_data[['width']])
    y = depth_data['time']
    model.fit(X, y)
    X_predict = poly.fit_transform(np.array([[target_width]]))
    predicted_time = model.predict(X_predict)[0]
    return predicted_time

# Method 3: Exponential Regression (for each depth value)
def exponential_func(x, a, b, c):
    return a * np.exp(b * x) + c

def predict_time_exponential_regression(target_width, target_depth, data):
    closest_depth = min(data['depth'].unique(), key=lambda x: abs(x - target_depth))
    depth_data = data[data['depth'] == closest_depth]
    X = depth_data['width']
    y = depth_data['time']
    try:
        popt, _ = curve_fit(exponential_func, X, y, maxfev=10000)
        predicted_time = exponential_func(target_width, *popt)
    except RuntimeError:
        print("Error: Exponential curve_fit failed to converge. Returning NaN.")
        predicted_time = np.nan
    return predicted_time

# Method 4: 2D Polynomial Regression
def predict_time_2d_polynomial_regression(target_width, target_depth, data, degree=2):
    model = LinearRegression()
    poly = PolynomialFeatures(degree=degree)
    X = poly.fit_transform(data[['width', 'depth']])
    y = data['time']
    model.fit(X, y)
    X_predict = poly.fit_transform(np.array([[target_width, target_depth]]))
    predicted_time = model.predict(X_predict)[0]
    return predicted_time

# --- Prediction for a Range of Qubit Values ---

# Target widths (qubits) for prediction
target_widths = np.arange(106, 151)
target_depth = 50  # You can change this

# Store predictions for each method
linear_predictions = []
polynomial_predictions = []
exponential_predictions = []
poly2d_predictions = []

for w in target_widths:
    linear_predictions.append(predict_time_linear_regression(w, target_depth, data))
    polynomial_predictions.append(predict_time_polynomial_regression(w, target_depth, data, degree=2))
    exponential_predictions.append(predict_time_exponential_regression(w, target_depth, data))
    poly2d_predictions.append(predict_time_2d_polynomial_regression(w, target_depth, data, degree=2))

# --- Plotting the Results ---

plt.figure(figsize=(12, 8))

plt.plot(target_widths, linear_predictions, label='Linear Regression', marker='o')
plt.plot(target_widths, polynomial_predictions, label='Polynomial Regression (degree=2)', marker='x')
plt.plot(target_widths, exponential_predictions, label='Exponential Regression', marker='s')
plt.plot(target_widths, poly2d_predictions, label='2D Polynomial Regression (degree=2)', marker='^')

# Mark the end of the original data
plt.axvline(x=105, color='gray', linestyle='--', label='End of Original Data')

plt.xlabel('Width (Number of Qubits)')
plt.ylabel('Predicted Time')
plt.title(f'Scaling Predictions for Depth={target_depth}')
plt.legend()
plt.grid(True)
plt.yscale('log')  # Use a logarithmic scale for the y-axis
plt.show()
